The Respawn Daemon
==================

The purpose of respawnd is to restart daemons if they should die unexpectedly.
Not only the daemon that died is restarted but also any other daemon that
has been started subsequent to the daemon that died and is under respawnd's
supervision. This way the system will probably be brought back to a working
state again.

Note: respawnd waits for all processes it starts to make sure that processes
are respawned in the same order they were registered for supervision. Therefore
respawning a process that "hangs" will also make respawnd "hang". Processes
supervised by respawnd must become daemons (or die) after initializing.

Start respawnd by simply running:

   respawnd

To put a daemon under the supervision of respawnd run:

   respawn-on /sbin/exampled arg1 arg2 arg3...

(...assuming respawnd itself is already running). It's important that exacly
the same command line that was used when starting the daemon is given as
argument(s) to respawn-on. To make respawnd not supervise it anymore run:

   respawn-off /sbin/exampled arg1 arg2 arg3...

or just

   respawn-off exampled

The latter makes respawnd ignore all processes named "exampled".


To Poll or To Be Notified
-------------------------

respawnd wakes up about every three seconds and looks through all procfs
cmdlines (/proc/[0-9]*/cmdline) for the processes running on the system. If one
of its supervised cmdlines is missing it will try to start that cmdline again.
You might argue that its bad thing to continuously wake up and check all
processes and that it would be better to be notified by the kernel when a
process dies.

I investigated using BSD Process Accounting, but to do that you
must let the kernel write to a regular file which you then have to stat now and
then instead (and by that risking that the file system gets full). I also tried
hacking the kernel to make it write the accounting information to a named pipe
instead. It worked, but then you could miss some information if the pipe ever
gets full (and respawnd mustn't miss any information!).

I couldn't find any other way to get notified when a process dies, except
letting respawnd itself start all the supervised processes, but we would like
to be able to use regular init.d scripts so the current implementation simply
checks the procfs now and then.

To detect bugs in respawnd it forks off a child process that does all the work
while the parent process just waits for it to die. The child doesn't save any
state information outside it's own process space so if it should die it won't
be able to recover properly. But the parent syslogs the death of the child so
you can find out its exit status and if it died from a signal (like SIGSEGV).


Why Restart More Than the Process That Died?
--------------------------------------------

The function of the system as a whole might be depending on the start order of
all services. Determining if this is the case is time consuming and not always
trivial. Therefore, if a process dies, respawnd restarts not only the missing
cmdline, but all processes that was added for supervision after the one that
died. This way we can be sure that all running services has been started in an
order that makes the system work. To test that the system can handle restart of
all services, we then only need to kill the first process added for supervision
and let respawnd restart everything before testing the system.


Bugs
----

If you find any bugs, please report them to the maintainer Jonas Holmberg
<jonashg@axis.com> or to the Axis Developer mailing list <dev-etrax@axis.com>.


License
-------

    Copyright (C) 2003  Axis Communications AB

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
  
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
  
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
