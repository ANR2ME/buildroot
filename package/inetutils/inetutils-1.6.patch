--- a/rshd/rshd.c
+++ b/rshd/rshd.c
@@ -306,7 +306,9 @@ extern char **environ;
 void
 doit (int sockfd, struct sockaddr_in *fromp)
 {
+#ifndef __uClinux__
   extern char *__rcmd_errstr;	/* syslog hook from libc/net/rcmd.c. */
+#endif
   struct hostent *hp;
   struct passwd *pwd;
   u_short port;
@@ -778,11 +780,13 @@ doit (int sockfd, struct sockaddr_in *fromp)
 	&& (iruserok (fromp->sin_addr.s_addr, pwd->pw_uid == 0,
 			remuser, locuser)) < 0)
     {
+#ifndef __uClinux__
       if (__rcmd_errstr)
 	syslog (LOG_INFO | LOG_AUTH,
 		"%s@%s as %s: permission denied (%s). cmd='%.80s'",
 		remuser, hostname, locuser, __rcmd_errstr, cmdbuf);
       else
+#endif
 	syslog (LOG_INFO | LOG_AUTH,
 		"%s@%s as %s: permission denied. cmd='%.80s'",
 		remuser, hostname, locuser, cmdbuf);
@@ -844,7 +848,12 @@ doit (int sockfd, struct sockaddr_in *fromp)
 	}
 # endif
 #endif
+
+#ifdef __uClinux__
+      pid = vfork ();
+#else
       pid = fork ();
+#endif
       if (pid == -1)
 	{
 	  rshd_error ("Can't fork; try again.\n");

--- a/rsh/rsh.c
+++ b/rsh/rsh.c
@@ -1,806 +1,499 @@
-/*-
- * Copyright (c) 1983, 1990, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/* Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
-   Free Software Foundation, Inc.
-
-   This file is part of GNU Inetutils.
-
-   GNU Inetutils is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   GNU Inetutils is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with GNU Inetutils; see the file COPYING.  If not, write
-   to the Free Software Foundation, Inc., 51 Franklin Street,
-   Fifth Floor, Boston, MA 02110-1301 USA. */
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
+/*
+    rsh.c - remote shell client
+    Copyright (C) 2003  Guus Sliepen <guus@sliepen.eu.org>
 
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/ioctl.h>
-#ifdef HAVE_SYS_FILIO_H
-# include <sys/filio.h>
-#endif
-#include <sys/file.h>
-#ifdef TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# ifdef HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License version 2 as published
+	by the Free Software Foundation.
 
-#include <netinet/in.h>
-#include <netdb.h>
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
-#include <errno.h>
-#include <pwd.h>
-#include <signal.h>
 #include <stdio.h>
+#include <stdbool.h>
+#include <unistd.h>
 #include <stdlib.h>
+#include <pwd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/poll.h>
+#include <netdb.h>
 #include <string.h>
-#include <unistd.h>
-#if defined(HAVE_STDARG_H) && defined(__STDC__) && __STDC__
-# include <stdarg.h>
-#else
-# include <varargs.h>
-#endif
-#include <getopt.h>
-#ifdef HAVE_SYS_SELECT_H
-# include <sys/select.h>
-#endif
+#include <errno.h>
+#include <fcntl.h>
+#include <libgen.h>
 
-#include <error.h>
-#include <progname.h>
-#include "xalloc.h"
+#define BUFLEN 0x10000
 
-#ifdef SHISHI
-# define REALM_SZ 1040
+#ifndef BINDIR
+#define BINDIR "/usr/bin"
 #endif
 
-#if defined(KERBEROS) || defined(SHISHI)
-int use_kerberos = 1, doencrypt;
-# ifdef KERBEROS
-#  include <kerberosIV/des.h>
-#  include <kerberosIV/krb.h>
-char dest_realm_buf[REALM_SZ], *dest_realm = NULL;
-CREDENTIALS cred;
-Key_schedule schedule;
-extern char *krb_realmofhost ();
-
-# elif defined(SHISHI)
-#  include <shishi.h>
-#  include "shishi_def.h"
-char dest_realm_buf[REALM_SZ], *dest_realm = NULL;
-
-Shishi *h;
-Shishi_key *enckey;
-shishi_ivector iv1, iv2, iv3, iv4;
-shishi_ivector *ivtab[4];
-
-int keytype;
-int keylen;
-int rc;
-int wlen;
-# endif
-#endif /* KERBEROS */
+static char *argv0;
 
-/*
- * rsh - remote shell
- */
-int rfd2;
-
-char *copyargs (char **);
-RETSIGTYPE sendsig (int);
-void talk (int, sigset_t *, pid_t, int);
-void usage (void);
-void warning (const char *, ...);
-
-
-#ifdef KERBEROS
-# ifdef ENCRYPTION
-#  define OPTIONS	"8Kdek:l:nxVh"
-# else
-#  define OPTIONS	"8Kdek:l:nVh"
-# endif
-#else
-# define OPTIONS	"8KLdel:nVh"
-#endif
-static const char *short_options = "+" OPTIONS;
-static struct option long_options[] = {
-  {"debug", no_argument, 0, 'd'},
-  {"user", required_argument, 0, 'l'},
-  {"escape", required_argument, 0, 'e'},
-  {"8-bit", no_argument, 0, '8'},
-  {"kerberos", no_argument, 0, 'K'},
-  {"no-input", no_argument, 0, 'n'},
-#if defined(KERBEROS) || defined(SHISHI)
-  {"realm", required_argument, 0, 'k'},
-  {"encrypt", no_argument, 0, 'x'},
-#endif
-  {"help", no_argument, 0, 'h'},
-  {"version", no_argument, 0, 'V'},
-  {0, 0, 0, 0}
-};
-
-static void
-pusage (FILE * stream)
-{
-  fprintf (stream,
-	   "Usage: %s [-nd%s]%s[-l USER] [USER@]HOST [COMMAND [ARG...]]\n",
-	   program_name,
-#if defined(KERBEROS) || defined(SHISHI)
-# ifdef ENCRYPTION
-	   "x", " [-k REALM] "
-# else
-	   "", " [-k REALM] "
-# endif
-#else
-	   "", " "
-#endif
-    );
+static void usage(void) {
+	fprintf(stderr, "Usage: %s [-46vn] [-l user] [-p port] [user@]host command...\n", argv0);
 }
 
-/* Print a help message describing all options to STDOUT and exit with a
-   status of 0.  */
-static void
-help (void)
-{
-  pusage (stdout);
-  puts ("Execute COMMAND on remote system HOST");
-  puts ("When use as rlogin:");
-  puts ("\
-  -8, --8-bit       allows an eight-bit input data path at all times");
-  puts ("\
-  -E, --no-escape   stops any character from being recognized as an escape\n\
-                    character");
-  puts ("\
-  -d, --debug       turns on socket debugging (see setsockopt(2))");
-  puts ("\
-  -e, --escape=CHAR allows user specification of the escape character,\n\
-                    which is ``~'' by default");
-  puts ("\
-  -l, --user USER   run as USER on the remote system");
-#if defined(KERBEROS) || defined(SHISHI)
-  puts ("\
-  -K, --kerberos    turns off all Kerberos authentication");
-  puts ("\
-  -k, --realm REALM Obtain tickets for the remote host in REALM\n\
-                    instead of the remote host's realm");
-# ifdef ENCRYPTION
-  puts ("\
-  -x, --encrypt     encrypt all data using DES");
-# endif
-#endif
-  puts ("\
-  -n, --no-input    use /dev/null as input");
-  puts ("\
-      --help        give this help list");
-  puts ("\
-  -V, --version     print program version");
-  fprintf (stdout, "\nSubmit bug reports to %s.\n", PACKAGE_BUGREPORT);
-  exit (0);
+/* Make sure everything gets written */
+
+static ssize_t safewrite(int fd, const void *buf, size_t count) {
+	int written = 0, result;
+	
+	while(count) {
+		result = write(fd, buf, count);
+		if(result == -1) {
+			if(errno == EINTR)
+				continue;
+			else
+				return result;
+		}
+		written += result;
+		buf += result;
+		count -= result;
+	}
+	
+	return written;
 }
 
-/* Print a message saying to use --help to STDERR, and exit with a status of
-   1.  */
-static void
-try_help (void)
-{
-  fprintf (stderr, "Try `%s --help' for more information.\n", program_name);
-  exit (1);
-}
+/* Safe and fast string building */
+
+static void safecpy(char **dest, int *len, const char *source, bool terminate) {
+	while(*source && *len) {
+		*(*dest)++ = *source++;
+		(*len)--;
+	}
 
-void
-usage ()
-{
-  pusage (stderr);
-  try_help ();
+	if(terminate && *len) {
+		*(*dest)++ = 0;
+		(*len)--;
+	}
 }
-
-
-int
-main (int argc, char **argv)
-{
-  struct passwd *pw;
-  struct servent *sp;
-  sigset_t sigs, osigs;
-  int asrsh, ch, dflag, nflag, rem;
-  pid_t pid = 0;
-  uid_t uid;
-  char *args, *host, *user;
-
-  set_program_name (argv[0]);
-
-  asrsh = dflag = nflag = 0;
-  host = user = NULL;
-
-  /* If called as something other than "rsh", use it as the host name */
-  {
-    char *p = strrchr (argv[0], '/');
-    if (p)
-      ++p;
-    else
-      p = argv[0];
-    if (strcmp (p, "rsh"))
-      host = p;
-    else
-      asrsh = 1;
-  }
-
-  while ((ch = getopt_long (argc, argv, short_options, long_options, 0))
-	 != EOF)
-    {
-      switch (ch)
-	{
-	case 'L':		/* -8Lew are ignored to allow rlogin aliases */
-	case 'e':
-	case 'w':
-	case '8':
-	  break;
-
-	case 'd':
-	  dflag = 1;
-	  break;
-
-	case 'l':
-	  user = optarg;
-	  break;
-
-	case 'K':
-#if defined(KERBEROS) || defined(SHISHI)
-	  use_kerberos = 0;
-#endif
-	  break;
-
-#if defined(KERBEROS) || defined(SHISHI)
-	case 'k':
-	  strncpy (dest_realm_buf, optarg, sizeof dest_realm_buf);
-	  dest_realm_buf[REALM_SZ - 1] = '\0';
-	  dest_realm = dest_realm_buf;
-	  break;
-
-# ifdef ENCRYPTION
-	case 'x':
-	  doencrypt = 1;
-#  ifdef KERBEROS
-	  des_set_key (cred.session, schedule);
-#  endif
-	  break;
-# endif
-#endif
 
-	case 'n':
-	  nflag = 1;
-	  break;
+static void closestdin(void) {
+	int fd;
 
-	case 'h':
-	  help ();
+	close(0);
 
-	case 'V':
-	  printf ("rsh (%s) %s\n", PACKAGE_NAME, PACKAGE_VERSION);
-	  exit (0);
+	if((fd = open("/dev/null", O_RDONLY)) < 0) {
+		fprintf(stderr, "%s: Error opening /dev/null: %s\n", argv0, strerror(errno));
+		exit(1);
+	}
 
-	case '?':
-	  try_help ();
+	if(fd != 0) {
+		dup2(fd, 0);
+		close(fd);
+	}
+}
 
-	default:
-	  usage ();
+int main(int argc, char **argv) {
+	char *user = NULL;
+	char *luser = NULL;
+	char *host = NULL;
+	char *port = "shell";
+	char *p;
+	char lport[5];
+	
+	struct passwd *pw;
+	
+	int af = AF_UNSPEC;
+	struct addrinfo hint, *ai, *aip, *lai;
+	int err, sock = -1, lsock = -1, esock = -1, i;
+	
+	int opt;
+
+	bool verbose = false;
+
+	char hostaddr[NI_MAXHOST];
+	char portnr[NI_MAXSERV];
+
+	char buf[3][BUFLEN], *bufp[3];
+	int len[3], wlen;
+	
+	fd_set infd, outfd, infdset, outfdset, errfd;
+	int maxfd;
+	
+	int flags;
+	
+	argv0 = argv[0];
+	
+	/* Lookup local username */
+	
+	if (!(pw = getpwuid(getuid()))) {
+		fprintf(stderr, "%s: Could not lookup username: %s\n", argv0, strerror(errno));
+		return 1;
+	}
+	user = luser = pw->pw_name;
+	
+	/* if we were called with something else from rsh use the name as host */
+	host = basename(argv0);
+
+	if(!strcmp(host, "rsh") || !strcmp(host, "rsh-redone-rsh"))
+		host = NULL;
+
+	/* Process options */
+			
+	while((opt = getopt(argc, argv, "-l:p:46vn")) != -1) {
+		switch(opt) {
+			case 1:
+				if(!host) {
+					host = optarg;
+					break;
+				} else {
+					optind--;
+					goto done;
+				}
+			case 'l':
+				user = optarg;
+				break;
+			case 'p':
+				port = optarg;
+				break;
+			case '4':
+				af = AF_INET;
+				break;
+			case '6':
+				af = AF_INET6;
+				break;
+			case 'v':
+				verbose = true;
+				break;
+			case 'n':
+				closestdin();
+				break;
+			default:
+				fprintf(stderr, "%s: Unknown option!\n", argv0);
+				usage();
+				return 1;
+		}
 	}
-    }
-
-  if (optind < argc)
-    host = argv[optind++];
-
-  /* To few args.  */
-  if (!host)
-    usage ();
-
-  /* If no further arguments, must have been called as rlogin. */
-  if (!argv[optind])
-    {
-      if (asrsh)
-	*argv = (char *) "rlogin";
-      seteuid (getuid ());
-      setuid (getuid ());
-      execv (PATH_RLOGIN, argv);
-      error (1, errno, "can't exec %s", PATH_RLOGIN);
-    }
-
-  argc -= optind;
-  argv += optind;
-
-  /* We must be setuid root.  */
-  if (geteuid ())
-    error (1, 0, "must be setuid root.\n");
-
-  if (!(pw = getpwuid (uid = getuid ())))
-    error (1, 0, "unknown user id");
-
-  /* Accept user1@host format, though "-l user2" overrides user1 */
-  {
-    char *p = strchr (host, '@');
-    if (p)
-      {
-	*p = '\0';
-	if (!user && p > host)
-	  user = host;
-	host = p + 1;
-	if (*host == '\0')
-	  usage ();
-      }
-  }
-
-#if defined(KERBEROS) || defined(SHISHI)
-# ifdef ENCRYPTION
-  /* -x turns off -n */
-  if (doencrypt)
-    nflag = 0;
-# endif
-#endif
 
-  args = copyargs (argv);
-
-  sp = NULL;
-#ifdef KERBEROS
-  if (use_kerberos)
-    {
-      sp = getservbyname ((doencrypt ? "ekshell" : "kshell"), "tcp");
-      if (sp == NULL)
-	{
-	  use_kerberos = 0;
-	  warning ("can't get entry for %s/tcp service",
-		   doencrypt ? "ekshell" : "kshell");
+done:
+	if(!host) {
+		fprintf(stderr, "%s: No host specified!\n", argv0);
+		usage();
+		return 1;
 	}
-    }
-#elif defined(SHISHI)
-  if (use_kerberos)
-    {
-      sp = getservbyname ("kshell", "tcp");
-      if (sp == NULL)
-	{
-	  use_kerberos = 0;
-	  warning ("can't get entry for %s/tcp service", "kshell");
+	
+	if(optind == argc) {
+		execv(BINDIR "/rlogin", argv);
+		fprintf(stderr, "%s: Could not execute " BINDIR "/rlogin: %s\n", argv0, strerror(errno));
+		return 1;
 	}
-    }
-#endif
-  if (sp == NULL)
-    sp = getservbyname ("shell", "tcp");
-  if (sp == NULL)
-    error (1, 0, "shell/tcp: unknown service");
-
-
-#if defined (KERBEROS) || defined(SHISHI)
-try_connect:
-  if (use_kerberos)
-    {
-      struct hostent *hp;
-
-      /* fully qualify hostname (needed for krb_realmofhost) */
-      hp = gethostbyname (host);
-      if (hp != NULL && !(host = strdup (hp->h_name)))
-	error (1, errno, "strdup");
-
-# if defined (KERBEROS)
-      rem = KSUCCESS;
-      errno = 0;
-      if (dest_realm == NULL)
-	dest_realm = krb_realmofhost (host);
-# elif defined (SHISHI)
-      rem = SHISHI_OK;
-      errno = 0;
-# endif
-
-# ifdef ENCRYPTION
-      if (doencrypt)
-#  if defined(SHISHI)
-	{
-	  int i;
-	  char *term;
-
-	  term = (char *) xmalloc (strlen (args) + 4);
-	  strcpy (term, "-x ");
-	  strcat (term, args);
-
-	  rem = krcmd_mutual (&h, &host, sp->s_port, &user, term, &rfd2,
-			      dest_realm, &enckey);
-	  if (rem > 0)
-	    {
-	      keytype = shishi_key_type (enckey);
-	      keylen = shishi_cipher_blocksize (keytype);
-
-	      ivtab[0] = &iv1;
-	      ivtab[1] = &iv2;
-	      ivtab[2] = &iv3;
-	      ivtab[3] = &iv4;
-
-	      for (i = 0; i < 4; i++)
-		{
-		  ivtab[i]->ivlen = keylen;
-
-		  switch (keytype)
-		    {
-		    case SHISHI_DES_CBC_CRC:
-		    case SHISHI_DES_CBC_MD4:
-		    case SHISHI_DES_CBC_MD5:
-		    case SHISHI_DES_CBC_NONE:
-		    case SHISHI_DES3_CBC_HMAC_SHA1_KD:
-		      ivtab[i]->keyusage = SHISHI_KEYUSAGE_KCMD_DES;
-		      ivtab[i]->iv = malloc (ivtab[i]->ivlen);
-		      memset (ivtab[i]->iv,
-			      2 * i + 1 * (i < 2) - 4 * (i >= 2),
-			      ivtab[i]->ivlen);
-		      ivtab[i]->ctx =
-			shishi_crypto (h, enckey, ivtab[i]->keyusage,
-				       shishi_key_type (enckey), ivtab[i]->iv,
-				       ivtab[i]->ivlen);
-		      break;
-		    case SHISHI_ARCFOUR_HMAC:
-		    case SHISHI_ARCFOUR_HMAC_EXP:
-		      ivtab[i]->keyusage =
-			SHISHI_KEYUSAGE_KCMD_DES + 2 + 4 * i;
-		      ivtab[i]->ctx =
-			shishi_crypto (h, enckey, ivtab[i]->keyusage,
-				       shishi_key_type (enckey), NULL, 0);
-		      break;
-		    default:
-		      ivtab[i]->keyusage =
-			SHISHI_KEYUSAGE_KCMD_DES + 2 + 4 * i;
-		      ivtab[i]->iv = malloc (ivtab[i]->ivlen);
-		      memset (ivtab[i]->iv, 0, ivtab[i]->ivlen);
-		      ivtab[i]->ctx =
-			shishi_crypto (h, enckey, ivtab[i]->keyusage,
-				       shishi_key_type (enckey), ivtab[i]->iv,
-				       ivtab[i]->ivlen);
-		    }
-		}
-	    }
-	  free (term);
+
+	if((p = strchr(host, '@'))) {
+		user = host;
+		*p = '\0';
+		host = p + 1;
 	}
-      else
-#  else
-	rem = krcmd_mutual (&host, sp->s_port, user, args, &rfd2,
-			    dest_realm, &cred, schedule);
-      else
-#  endif
-# endif
-	rem = krcmd (
-# if defined (SHISHI)
-		      &h, &host, sp->s_port, &user, args, &rfd2, dest_realm);
-# else
-		      &host, sp->s_port, user, args, &rfd2, dest_realm);
-# endif
-      if (rem < 0)
-	{
-	  use_kerberos = 0;
-	  sp = getservbyname ("shell", "tcp");
-	  if (sp == NULL)
-	    error (1, 0, "shell/tcp: unknown service");
-	  if (errno == ECONNREFUSED)
-	    warning ("remote host doesn't support Kerberos");
-	  if (errno == ENOENT)
-	    warning ("can't provide Kerberos auth data");
-	  goto try_connect;
+	
+	/* Resolve hostname and try to make a connection */
+	
+	memset(&hint, '\0', sizeof hint);
+	hint.ai_family = af;
+	hint.ai_socktype = SOCK_STREAM;
+	
+	err = getaddrinfo(host, port, &hint, &ai);
+	
+	if(err) {
+		fprintf(stderr, "%s: Error looking up host: %s\n", argv0, gai_strerror(err));
+		return 1;
 	}
-    }
-  else
-    {
-      if (!user)
-	user = pw->pw_name;
-      if (doencrypt)
-	error (1, 0, "the -x flag requires Kerberos authentication");
-      rem = rcmd (&host, sp->s_port, pw->pw_name, user, args, &rfd2);
-    }
-#else
-  if (!user)
-    user = pw->pw_name;
-  rem = rcmd (&host, sp->s_port, pw->pw_name, user, args, &rfd2);
-#endif
+	
+	hint.ai_flags = AI_PASSIVE;
+	
+	for(aip = ai; aip; aip = aip->ai_next) {
+		if(getnameinfo(aip->ai_addr, aip->ai_addrlen, hostaddr, sizeof hostaddr, portnr, sizeof portnr, NI_NUMERICHOST | NI_NUMERICSERV)) {
+			fprintf(stderr, "%s: Error resolving address: %s\n", argv0, strerror(errno));
+			return 1;
+		}
+		if(verbose) fprintf(stderr, "Trying %s port %s...", hostaddr, portnr);
+		
+		if((sock = socket(aip->ai_family, aip->ai_socktype, aip->ai_protocol)) == -1) {
+			if(verbose) fprintf(stderr, " Could not open socket: %s\n", strerror(errno));
+			continue;
+		}
 
-  if (rem < 0)
-    exit (1);
-
-  if (rfd2 < 0)
-    error (1, 0, "can't establish stderr");
-
-  if (dflag)
-    {
-      int one = 1;
-      if (setsockopt (rem, SOL_SOCKET, SO_DEBUG, (char *) &one,
-		      sizeof one) < 0)
-	error (0, errno, "setsockopt");
-      if (setsockopt (rfd2, SOL_SOCKET, SO_DEBUG, (char *) &one,
-		      sizeof one) < 0)
-	error (0, errno, "setsockopt");
-    }
-
-  seteuid (uid);
-  setuid (uid);
-#ifdef HAVE_SIGACTION
-  sigemptyset (&sigs);
-  sigaddset (&sigs, SIGINT);
-  sigaddset (&sigs, SIGQUIT);
-  sigaddset (&sigs, SIGTERM);
-  sigprocmask (SIG_BLOCK, &sigs, &osigs);
-#else
-  sigs = sigmask (SIGINT) | sigmask (SIGQUIT) | sigmask (SIGTERM);
-  osigs = sigblock (sigs);
-#endif
-  if (signal (SIGINT, SIG_IGN) != SIG_IGN)
-    signal (SIGINT, sendsig);
-  if (signal (SIGQUIT, SIG_IGN) != SIG_IGN)
-    signal (SIGQUIT, sendsig);
-  if (signal (SIGTERM, SIG_IGN) != SIG_IGN)
-    signal (SIGTERM, sendsig);
-
-  if (!nflag)
-    {
-      pid = fork ();
-      if (pid < 0)
-	error (1, errno, "fork");
-    }
-
-#if defined(KERBEROS) || defined(SHISHI)
-# ifdef ENCRYPTION
-  if (!doencrypt)
-# endif
-#endif
-    {
-      int one = 1;
-      ioctl (rfd2, FIONBIO, &one);
-      ioctl (rem, FIONBIO, &one);
-    }
-
-  talk (nflag, &osigs, pid, rem);
-
-
-#ifdef SHISHI
-  if (use_kerberos)
-    {
-      int i;
-
-      shishi_done (h);
-# ifdef ENCRYPTION
-      if (doencrypt)
-	{
-	  shishi_key_done (enckey);
-	  for (i = 0; i < 4; i++)
-	    {
-	      shishi_crypto_close (ivtab[i]->ctx);
-	      free (ivtab[i]->iv);
-	    }
+		hint.ai_family = aip->ai_family;
+
+		/* Bind to a privileged port */
+				
+		for(i = 1023; i >= 512; i--) {
+			snprintf(lport, sizeof lport, "%d", i);
+			err = getaddrinfo(NULL, lport, &hint, &lai);
+			if(err) {
+				fprintf(stderr, " Error looking up localhost: %s\n", gai_strerror(err));
+				return 1;
+			}
+			
+			err = bind(sock, lai->ai_addr, lai->ai_addrlen);
+			
+			freeaddrinfo(lai);
+			
+			if(err)
+				continue;
+			else
+				break;
+		}
+		
+		if(err) {
+			if(verbose) fprintf(stderr, " Could not bind to privileged port: %s\n", strerror(errno));
+			continue;
+		}
+		
+		if(connect(sock, aip->ai_addr, aip->ai_addrlen) == -1) {
+			if(verbose) fprintf(stderr, " Connection failed: %s\n", strerror(errno));
+			continue;
+		}
+		if(verbose) fprintf(stderr, " Connected.\n");
+		break;
 	}
-# endif
-    }
-#endif
+	
+	if(!aip) {
+		fprintf(stderr, "%s: Could not make a connection.\n", argv0);
+		return 1;
+	}
+	
+	/* Create a socket for the incoming connection for stderr output */
+	
+	if((lsock = socket(aip->ai_family, aip->ai_socktype, aip->ai_protocol)) == -1) {
+		fprintf(stderr, "%s: Could not open socket: %s\n", argv0, strerror(errno));
+		return 1;
+	}
+	
+	hint.ai_family = aip->ai_family;
+	
+	freeaddrinfo(ai);
+	
+	for(i--; i >= 512; i--) {
+		snprintf(lport, sizeof lport, "%d", i);
+		err = getaddrinfo(NULL, lport, &hint, &lai);
+		if(err) {
+			fprintf(stderr, "%s: Error looking up localhost: %s\n", argv0, gai_strerror(err));
+			return 1;
+		}
 
-  if (!nflag)
-    kill (pid, SIGKILL);
-  return 0;
-}
+		err = bind(lsock, lai->ai_addr, lai->ai_addrlen);
+
+		freeaddrinfo(lai);
 
-void
-talk (int nflag, sigset_t * osigs, pid_t pid, int rem)
-{
-  int cc, wc;
-  fd_set readfrom, ready, rembits;
-  char *bp, buf[BUFSIZ];
-
-  if (!nflag && pid == 0)
-    {
-      close (rfd2);
-
-    reread:
-      errno = 0;
-      if ((cc = read (STDIN_FILENO, buf, sizeof buf)) <= 0)
-	goto done;
-      bp = buf;
-
-    rewrite:
-      FD_ZERO (&rembits);
-      FD_SET (rem, &rembits);
-      if (select (rem + 1, 0, &rembits, 0, 0) < 0)
-	{
-	  if (errno != EINTR)
-	    error (1, errno, "select");
-	  goto rewrite;
+		if(err)
+			continue;
+		else
+			break;
 	}
-      if (!FD_ISSET (rem, &rembits))
-	goto rewrite;
-#ifdef ENCRYPTION
-# ifdef KERBEROS
-      if (doencrypt)
-	wc = des_write (rem, bp, cc);
-      else
-# elif defined(SHISHI)
-      if (doencrypt)
-	writeenc (h, rem, bp, cc, &wc, &iv3, enckey, 2);
-      else
-# endif
-#endif
-	wc = write (rem, bp, cc);
-      if (wc < 0)
-	{
-	  if (errno == EWOULDBLOCK)
-	    goto rewrite;
-	  goto done;
+	
+	if(err) {
+		fprintf(stderr, "%s: Could not bind to privileged port: %s\n", argv0, strerror(errno));
+		return 1;
 	}
-      bp += wc;
-      cc -= wc;
-      if (cc == 0)
-	goto reread;
-      goto rewrite;
-    done:
-      shutdown (rem, 1);
-      exit (0);
-    }
-
-#ifdef HAVE_SIGACTION
-  sigprocmask (SIG_SETMASK, osigs, NULL);
-#else
-  sigsetmask (*osigs);
-#endif
-  FD_ZERO (&readfrom);
-  FD_SET (rfd2, &readfrom);
-  FD_SET (rem, &readfrom);
-  do
-    {
-      int maxfd = rem;
-      if (rfd2 > maxfd)
-	maxfd = rfd2;
-      ready = readfrom;
-      if (select (maxfd + 1, &ready, 0, 0, 0) < 0)
-	{
-	  if (errno != EINTR)
-	    error (1, errno, "select");
-	  continue;
+	
+	if(listen(lsock, 10)) {
+		fprintf(stderr, "%s: Could not listen: %s\n", argv0, strerror(errno));
+		return 1;
 	}
-      if (FD_ISSET (rfd2, &ready))
-	{
-	  errno = 0;
-#ifdef KERBEROS
-# ifdef CRYPT
-	  if (doenencryption)
-	    cc = des_read (rfd2, buf, sizeof buf);
-	  else
-# endif
-#elif defined(SHISHI) && defined(ENCRYPTION)
-	  if (doencrypt)
-	    readenc (h, rfd2, buf, &cc, &iv2, enckey, 2);
-	  else
-#endif
-	    cc = read (rfd2, buf, sizeof buf);
-	  if (cc <= 0)
-	    {
-	      if (errno != EWOULDBLOCK)
-		FD_CLR (rfd2, &readfrom);
-	    }
-	  else
-	    write (2, buf, cc);
+	
+	/* Drop privileges */
+	
+	if(setuid(getuid())) {
+		fprintf(stderr, "%s: Unable to drop privileges: %s\n", argv0, strerror(errno));
+		return 1;
 	}
-      if (FD_ISSET (rem, &ready))
-	{
-	  errno = 0;
-#ifdef KERBEROS
-# ifdef ENCRYPTION
-	  if (doencrypt)
-	    cc = des_read (rem, buf, sizeof buf);
-	  else
-# endif
-#elif defined(SHISHI) && defined(ENCRYPTION)
-	  if (doencrypt)
-	    readenc (h, rem, buf, &cc, &iv1, enckey, 2);
-	  else
-#endif
-	    cc = read (rem, buf, sizeof buf);
-	  if (cc <= 0)
-	    {
-	      if (errno != EWOULDBLOCK)
-		FD_CLR (rem, &readfrom);
-	    }
-	  else
-	    write (1, buf, cc);
+	
+	/* Send required information to the server */
+	
+	bufp[0] = buf[0];
+	len[0] = sizeof buf[0];
+	safecpy(&bufp[0], &len[0], lport, 1);
+	safecpy(&bufp[0], &len[0], luser, 1);
+	safecpy(&bufp[0], &len[0], user, 1);
+
+	for(; optind < argc; optind++) {
+		safecpy(&bufp[0], &len[0], argv[optind], 0);
+		if(optind < argc - 1)
+			safecpy(&bufp[0], &len[0], " ", 0);
+	}
+	safecpy(&bufp[0], &len[0], "", 1);
+	
+	if(!len[0]) {
+		fprintf(stderr, "%s: Arguments too long!\n", argv0);
+		return 1;
+	}
+	
+	if(safewrite(sock, buf[0], bufp[0] - buf[0]) == -1) {
+		fprintf(stderr, "%s: Unable to send required information: %s\n", argv0, strerror(errno));
+		return 1;
 	}
-    }
-  while (FD_ISSET (rfd2, &readfrom) || FD_ISSET (rem, &readfrom));
-}
 
-void
-sendsig (int sig)
-{
-  char signo;
+	/* Wait for acknowledgement from server */
+	
+	errno = 0;
+	
+	if(read(sock, buf[0], 1) != 1 || *buf[0]) {
+		fprintf(stderr, "%s: Didn't receive NULL byte from server: %s\n", argv0, strerror(errno));
+		return 1;
+	}
 
-#if defined(SHISHI) && defined (ENCRYPTION)
-  int n;
-#endif
+	/* Wait for incoming connection from server */
+	
+	if((esock = accept(lsock, NULL, 0)) == -1) {
+		fprintf(stderr, "%s: Could not accept stderr connection: %s\n", argv0, strerror(errno));
+		return 1;
+	}
+	
+	close(lsock);
+	
+	/* Process input/output */
+
+	flags = fcntl(sock, F_GETFL);
+	fcntl(sock, F_SETFL, flags | O_NONBLOCK);
+	flags = fcntl(esock, F_GETFL);
+	fcntl(esock, F_SETFL, flags | O_NONBLOCK);
+	
+	bufp[0] = buf[0];
+	bufp[1] = buf[1];
+	bufp[2] = buf[2];
+	
+	FD_ZERO(&infdset);
+	FD_ZERO(&outfdset);
+	FD_SET(0, &infdset);
+	FD_SET(sock, &infdset);
+	FD_SET(esock, &infdset);
+	
+	maxfd = (sock>esock?sock:esock) + 1;
+	
+	for(;;) {
+		errno = 0;
+		infd = infdset;
+		outfd = outfdset;
+		errfd = infdset;
+	
+		if(select(maxfd, &infd, &outfd, &errfd, NULL) <= 0) {
+			if(errno == EINTR)
+				continue;
+			else
+				break;
+		}
 
-  signo = sig;
-#ifdef KERBEROS
-# ifdef ENCRYPTION
-  if (doencrypt)
-    des_write (rfd2, &signo, 1);
-  else
-# endif
-#elif defined(SHISHI) && defined (ENCRYPTION)
-  if (doencrypt)
-    writeenc (h, rfd2, &signo, 1, &n, &iv4, enckey, 2);
-  else
-#endif
 
-    write (rfd2, &signo, 1);
-}
+		if(FD_ISSET(esock, &infd)) {
+			len[2] = read(esock, buf[2], BUFLEN);
+			if(len[2] <= 0) {
+				if(errno != EINTR && errno != EAGAIN) {
+					if(FD_ISSET(sock, &infdset) || FD_ISSET(1, &outfdset))
+						FD_CLR(esock, &infdset);
+					else
+						break;
+				}
+			} else {
+				FD_SET(2, &outfdset);
+				FD_CLR(esock, &infdset);
+			}
+		} else {
+			len[2] = 0;
+		}
 
-#if defined(KERBEROS) || defined(SHISHI)
-void
-warning (const char *fmt, ...)
-{
-  va_list ap;
-
-  fprintf (stderr, "%s: warning, using standard rsh: ", program_name);
-  va_start (ap, fmt);
-  fmt = va_arg (ap, char *);
-  vfprintf (stderr, fmt, ap);
-  va_end (ap);
-  fprintf (stderr, ".\n");
-}
-#endif
+		if(FD_ISSET(2, &outfd)) {
+			wlen = write(2, bufp[2], len[2]);
+			if(wlen <= 0) {
+				if(errno != EINTR && errno != EAGAIN) {
+					if(FD_ISSET(sock, &infdset) || FD_ISSET(1, &outfdset))
+						FD_CLR(esock, &infdset);
+					else
+						break;
+				}
+			} else {
+				len[2] -= wlen;
+				bufp[2] += wlen;
+				if(!len[2]) {
+					FD_CLR(2, &outfdset);
+					FD_SET(esock, &infdset);
+					bufp[2] = buf[2];
+				}
+			}
+		}
 
-char *
-copyargs (char **argv)
-{
-  int cc;
-  char **ap, *args, *p;
-
-  cc = 0;
-  for (ap = argv; *ap; ++ap)
-    cc += strlen (*ap) + 1;
-  if (!(args = malloc ((u_int) cc)))
-    error (1, errno, "copyargs");
-  for (p = args, ap = argv; *ap; ++ap)
-    {
-      strcpy (p, *ap);
-      for (p = strcpy (p, *ap); *p; ++p);
-      if (ap[1])
-	*p++ = ' ';
-    }
-  return args;
+		if(FD_ISSET(sock, &infd)) {
+			len[1] = read(sock, buf[1], BUFLEN);
+			if(len[1] <= 0) {
+				if(errno != EINTR && errno != EAGAIN) {
+					if(FD_ISSET(esock, &infdset) || FD_ISSET(2, &outfdset))
+						FD_CLR(sock, &infdset);
+					else
+						break;
+				}
+			} else {
+				FD_SET(1, &outfdset);
+				FD_CLR(sock, &infdset);
+			}
+		}
+
+		if(FD_ISSET(1, &outfd)) {
+			wlen = write(1, bufp[1], len[1]);
+			if(wlen <= 0) {
+				if(errno != EINTR && errno != EAGAIN) {
+					if(FD_ISSET(esock, &infdset) || FD_ISSET(2, &outfdset))
+						FD_CLR(sock, &infdset);
+					else
+						break;
+				}
+			} else {
+				len[1] -= wlen;
+				bufp[1] += wlen;
+				if(!len[1]) {
+					FD_CLR(1, &outfdset);
+					FD_SET(sock, &infdset);
+					bufp[1] = buf[1];
+				}
+			}
+		}
+
+		if(FD_ISSET(0, &infd)) {
+			len[0] = read(0, buf[0], BUFLEN);
+			if(len[0] <= 0) {
+				if(errno != EINTR && errno != EAGAIN) {
+					FD_CLR(0, &infdset);
+					shutdown(sock, SHUT_WR);
+				}
+			} else {
+				FD_SET(sock, &outfdset);
+				FD_CLR(0, &infdset);
+			}
+		}
+
+		if(FD_ISSET(sock, &outfd)) {
+			wlen = write(sock, bufp[0], len[0]);
+			if(wlen <= 0) {
+				if(errno != EINTR && errno != EAGAIN)
+					break;
+			} else {
+				len[0] -= wlen;
+				bufp[0] += wlen;
+				if(!len[0]) {
+					FD_CLR(sock, &outfdset);
+					FD_SET(0, &infdset);
+					bufp[0] = buf[0];
+				}
+			}
+		}
+
+		
+	}
+		
+	if(errno) {
+		fprintf(stderr, "%s: %s\n", argv0, strerror(errno));
+		return 1;
+	}
+	
+	close(sock);
+	close(esock);
+	
+	return 0;
 }
