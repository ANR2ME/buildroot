From c551dd925c54fbbfe68f627ca01e95bb12932e41 Mon Sep 17 00:00:00 2001
From: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date: Mon, 20 Jun 2011 18:09:10 +0200
Subject: [PATCH 02/12] Add serial activity LED trigger driver

Patch taken from
http://www.mail-archive.com/netdev@vger.kernel.org/msg38825.html,
updated to the latest kernel and modified to be used as a serial
activity LED trigger.

Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
---
 drivers/leds/Kconfig              |    8 ++++
 drivers/leds/Makefile             |    1 +
 drivers/leds/ledtrig-serial.c     |   92 +++++++++++++++++++++++++++++++++++++
 drivers/tty/serial/atmel_serial.c |    2 +-
 drivers/tty/serial/serial_core.c  |   16 +++++++
 include/linux/leds.h              |    7 +++
 include/linux/serial_core.h       |   23 +++++++++-
 7 files changed, 147 insertions(+), 2 deletions(-)
 create mode 100644 drivers/leds/ledtrig-serial.c

diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index d9bedf8..c6573f7 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -448,6 +448,14 @@ config LEDS_TRIGGER_NETWORK_ACT
 	  layer-3 networking.
 	  If unsure, say Y.
 
+config LEDS_TRIGGER_SERIAL_ACT
+	tristate "LED Serial Activity Trigger"
+	depends on LEDS_TRIGGERS
+	depends on SERIAL_CORE
+	help
+	  This allow LEDs to be controlled by serial port activity.
+	  If unsure, say Y.
+
 config LEDS_TRIGGER_HEARTBEAT
 	tristate "LED Heartbeat Trigger"
 	depends on LEDS_TRIGGERS
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index bb59bda..6da8b96 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -54,6 +54,7 @@ obj-$(CONFIG_LEDS_DAC124S085)		+= leds-dac124s085.o
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
 obj-$(CONFIG_LEDS_TRIGGER_IDE_DISK)	+= ledtrig-ide-disk.o
 obj-$(CONFIG_LEDS_TRIGGER_NETWORK_ACT)	+= ledtrig-network.o
+obj-$(CONFIG_LEDS_TRIGGER_SERIAL_ACT)	+= ledtrig-serial.o
 obj-$(CONFIG_LEDS_TRIGGER_HEARTBEAT)	+= ledtrig-heartbeat.o
 obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+= ledtrig-backlight.o
 obj-$(CONFIG_LEDS_TRIGGER_GPIO)		+= ledtrig-gpio.o
diff --git a/drivers/leds/ledtrig-serial.c b/drivers/leds/ledtrig-serial.c
new file mode 100644
index 0000000..cc732fc
--- /dev/null
+++ b/drivers/leds/ledtrig-serial.c
@@ -0,0 +1,92 @@
+/*
+ * LED Serial Activity Trigger
+ * based on ledtrig-network by Florian Fainelli
+ * based on ledtrig-ide-disk by Richard Purdie
+ *
+ * Copyright 2007 Florian Fainelli <florian@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/leds.h>
+
+#define LEDTRIG_SERIAL_ON_DURATION_MSECS 100
+
+static void ledtrig_serial_timerfunc(unsigned long data);
+
+DEFINE_LED_TRIGGER(ledtrig_serial_rx);
+DEFINE_LED_TRIGGER(ledtrig_serial_tx);
+static DEFINE_TIMER(ledtrig_serial_timer, ledtrig_serial_timerfunc, 0, 0);
+static int serial_rx_activity, serial_rx_lastactivity;
+static int serial_tx_activity, serial_tx_lastactivity;
+
+void ledtrig_serial_rx_activity(void)
+{
+	serial_rx_activity++;
+	if (!timer_pending(&ledtrig_serial_timer))
+		mod_timer(&ledtrig_serial_timer, jiffies +
+			  msecs_to_jiffies(LEDTRIG_SERIAL_ON_DURATION_MSECS));
+}
+EXPORT_SYMBOL(ledtrig_serial_rx_activity);
+
+void ledtrig_serial_tx_activity(void)
+{
+	serial_tx_activity++;
+	if (!timer_pending(&ledtrig_serial_timer))
+		mod_timer(&ledtrig_serial_timer, jiffies +
+			  msecs_to_jiffies(LEDTRIG_SERIAL_ON_DURATION_MSECS));
+}
+EXPORT_SYMBOL(ledtrig_serial_tx_activity);
+
+static void ledtrig_serial_timerfunc(unsigned long data)
+{
+	int has_activity = 0;
+
+	if (serial_rx_lastactivity != serial_rx_activity) {
+		serial_rx_lastactivity = serial_rx_activity;
+		led_trigger_event(ledtrig_serial_rx, LED_FULL);
+		has_activity = 1;
+	}
+	else
+		led_trigger_event(ledtrig_serial_rx, LED_OFF);
+
+	if (serial_tx_lastactivity != serial_tx_activity) {
+		serial_tx_lastactivity = serial_tx_activity;
+		led_trigger_event(ledtrig_serial_tx, LED_FULL);
+		has_activity = 1;
+	}
+	else
+		led_trigger_event(ledtrig_serial_tx, LED_OFF);
+
+	if (has_activity)
+		mod_timer(&ledtrig_serial_timer,
+			  jiffies + msecs_to_jiffies(LEDTRIG_SERIAL_ON_DURATION_MSECS));
+}
+
+static int __init ledtrig_serial_init(void)
+{
+       led_trigger_register_simple("serial-rx", &ledtrig_serial_rx);
+       led_trigger_register_simple("serial-tx", &ledtrig_serial_tx);
+       return 0;
+}
+
+static void __exit ledtrig_serial_exit(void)
+{
+       led_trigger_unregister_simple(ledtrig_serial_rx);
+       led_trigger_unregister_simple(ledtrig_serial_tx);
+}
+
+module_init(ledtrig_serial_init);
+module_exit(ledtrig_serial_exit);
+
+MODULE_AUTHOR("Florian Fainelli <florian@openwrt.org>");
+MODULE_DESCRIPTION("LED Serial Activity trigger");
+MODULE_LICENSE("GPL");
diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c
index 10605ec..fa6b975 100644
--- a/drivers/tty/serial/atmel_serial.c
+++ b/drivers/tty/serial/atmel_serial.c
@@ -817,7 +817,7 @@ static void atmel_rx_from_dma(struct uart_port *port)
 			 */
 			count = head - tail;
 
-			tty_insert_flip_string(tty, pdc->buf + pdc->ofs, count);
+			uart_insert_string(port, pdc->buf + pdc->ofs, count);
 
 			dma_sync_single_for_device(port->dev, pdc->dma_addr,
 					pdc->dma_size, DMA_FROM_DEVICE);
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 1305618..a843e0d 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -2526,6 +2526,11 @@ void uart_insert_char(struct uart_port *port, unsigned int status,
 {
 	struct tty_struct *tty = port->state->port.tty;
 
+	/* Trigger the LED only if it's not the port holding
+	   the kernel console */
+	if (! port->cons || port->cons->index != port->line)
+		ledtrig_serial_rx_activity();
+
 	if ((status & port->ignore_status_mask & ~overrun) == 0)
 		tty_insert_flip_char(tty, ch, flag);
 
@@ -2538,6 +2543,17 @@ void uart_insert_char(struct uart_port *port, unsigned int status,
 }
 EXPORT_SYMBOL_GPL(uart_insert_char);
 
+int uart_insert_string(struct uart_port *port, const unsigned char *chars, size_t size)
+{
+	/* Trigger the LED only if it's not the port holding
+	   the kernel console */
+	if (! port->cons || port->cons->index != port->line)
+		ledtrig_serial_rx_activity();
+
+	return tty_insert_flip_string(port->state->port.tty, chars, size);
+}
+EXPORT_SYMBOL_GPL(uart_insert_string);
+
 EXPORT_SYMBOL(uart_write_wakeup);
 EXPORT_SYMBOL(uart_register_driver);
 EXPORT_SYMBOL(uart_unregister_driver);
diff --git a/include/linux/leds.h b/include/linux/leds.h
index 36abea1..b230db5 100644
--- a/include/linux/leds.h
+++ b/include/linux/leds.h
@@ -171,6 +171,13 @@ extern void ledtrig_network_activity(void);
 #else
 #define ledtrig_network_activity() do {} while(0)
 #endif
+#ifdef CONFIG_LEDS_TRIGGER_SERIAL_ACT
+extern void ledtrig_serial_rx_activity(void);
+extern void ledtrig_serial_tx_activity(void);
+#else
+#define ledtrig_serial_tx_activity() do {} while(0)
+#define ledtrig_serial_rx_activity() do {} while(0)
+#endif
 
 /*
  * Generic LED platform data for describing LED names and default triggers.
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index c91ace7..fd3ad18 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -21,6 +21,8 @@
 #define LINUX_SERIAL_CORE_H
 
 #include <linux/serial.h>
+#include <linux/leds.h>
+#include <linux/console.h>
 
 /*
  * The type definitions.  These are from Ted Ts'o's serial.h
@@ -468,7 +470,23 @@ int uart_match_port(struct uart_port *port1, struct uart_port *port2);
 int uart_suspend_port(struct uart_driver *reg, struct uart_port *port);
 int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
 
-#define uart_circ_empty(circ)		((circ)->head == (circ)->tail)
+static inline int uart_circ_empty(struct circ_buf *circ)
+{
+	if (circ->head == circ->tail)
+		return 1;
+	else {
+		struct uart_state *state = container_of(circ, struct uart_state, xmit);
+		struct uart_port *port = state->uart_port;
+
+		/* Trigger the LED only if it's not the port holding
+		   the kernel console */
+		if (! port->cons || port->cons->index != port->line)
+			ledtrig_serial_tx_activity();
+
+		return 0;
+	}
+}
+
 #define uart_circ_clear(circ)		((circ)->head = (circ)->tail = 0)
 
 #define uart_circ_chars_pending(circ)	\
@@ -497,6 +515,9 @@ extern void uart_handle_cts_change(struct uart_port *uport,
 extern void uart_insert_char(struct uart_port *port, unsigned int status,
 		 unsigned int overrun, unsigned int ch, unsigned int flag);
 
+extern int uart_insert_string(struct uart_port *port,
+		 const unsigned char *chars, size_t size);
+
 #ifdef SUPPORT_SYSRQ
 static inline int
 uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
-- 
1.7.9.5

