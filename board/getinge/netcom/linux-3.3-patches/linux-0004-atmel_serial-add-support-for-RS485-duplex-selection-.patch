From dde80c14594d611790eed51315e8868993abfafe Mon Sep 17 00:00:00 2001
From: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date: Mon, 27 Jun 2011 14:35:34 +0200
Subject: [PATCH 04/11] atmel_serial: add support for RS485 duplex selection pin

We extend the driver platform_data structure with two new fields:

 - has_rs485_duplex_pin, which allows the board file to tell whether
   this serial link has a pin for duplex mode selection in RS485

 - rs485_duplex_pin, which allows the board file to tell the serial
   driver which GPIO pin to use to configure the duplex mode

The atmel_serial driver then drives the duplex pin low or high
depending on whether full or half duplex mode is selected.

Technically speaking, the patch isn't entirely correct: the
association between pin low/high and duplex half/full is specific to
the transceiver, which is outside of the AT91 chip. So, the code to
actually switch between duplex modes should instead call into callback
functions provided by the board file. This would however complexify
the implementation, without any real gain in the context of Getinge's
system.

Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
---
 arch/arm/mach-at91/include/mach/board.h |    2 ++
 drivers/tty/serial/atmel_serial.c       |   30 ++++++++++++++++++++++++++++++
 2 files changed, 32 insertions(+), 0 deletions(-)

Index: b/arch/arm/mach-at91/include/mach/board.h
===================================================================
--- a/arch/arm/mach-at91/include/mach/board.h
+++ b/arch/arm/mach-at91/include/mach/board.h
@@ -141,6 +141,8 @@
 	short			use_dma_rx;	/* use receive DMA? */
 	void __iomem		*regs;		/* virt. base address, if any */
 	struct serial_rs485	rs485;		/* rs485 settings */
+	short                   has_rs485_duplex_pin; /* has a pin for RS485 duplex selection ? */
+	u8                      rs485_duplex_pin;     /* the pin for RS485 duplex selection */
 };
 extern void __init at91_add_device_serial(void);
 
Index: b/drivers/tty/serial/atmel_serial.c
===================================================================
--- a/drivers/tty/serial/atmel_serial.c
+++ b/drivers/tty/serial/atmel_serial.c
@@ -155,6 +155,8 @@
 	struct circ_buf		rx_ring;
 
 	struct serial_rs485	rs485;		/* rs485 settings */
+	short                   has_rs485_duplex_pin;
+	u8                      rs485_duplex_pin;
 	unsigned int		tx_done_mask;
 };
 
@@ -226,6 +228,11 @@
 
 	atmel_port->rs485 = *rs485conf;
 
+  /* Set duplex pin regardless of whether rs485 is enabled or not */
+	if (atmel_port->has_rs485_duplex_pin)
+		gpio_set_value(atmel_port->rs485_duplex_pin,
+			       (atmel_port->rs485.flags & SER_RS485_HALF_DUPLEX) ? 1 : 0);
+
 	if (rs485conf->flags & SER_RS485_ENABLED) {
 		dev_dbg(port->dev, "Setting UART to RS485\n");
 		atmel_port->tx_done_mask = ATMEL_US_TXEMPTY;
@@ -989,6 +996,12 @@
 	atmel_port->irq_status_prev = UART_GET_CSR(port);
 	atmel_port->irq_status = atmel_port->irq_status_prev;
 
+	/* Set the RS 485 duplex GPIO pin to the correct value if present */
+	if (atmel_port->has_rs485_duplex_pin)
+  	gpio_set_value(atmel_port->rs485_duplex_pin, 
+      atmel_port->rs485.flags & (SER_RS485_ENABLED | SER_RS485_HALF_DUPLEX)
+       ? 1 : 0);
+
 	/*
 	 * Finally, enable the serial port
 	 */
@@ -1507,6 +1520,22 @@
 	} else {
 		atmel_port->tx_done_mask = ATMEL_US_TXRDY;
 	}
+
+	/* Request and configure the RS 485 duplex GPIO pin */
+	atmel_port->rs485_duplex_pin = pdata->rs485_duplex_pin;
+	atmel_port->has_rs485_duplex_pin = pdata->has_rs485_duplex_pin;
+
+	if (atmel_port->has_rs485_duplex_pin) {
+		int ret = gpio_request(atmel_port->rs485_duplex_pin, "rs485_duplex");
+		if (ret) {
+			pr_err("atmel_serial: Cannot initialize RS485 duplex pin %d\n", ret);
+			atmel_port->rs485_duplex_pin = -EINVAL;
+			atmel_port->has_rs485_duplex_pin = 0;
+		} else
+			gpio_direction_output(atmel_port->rs485_duplex_pin, 0);
+	}
+
+
 }
 
 /*
@@ -1856,6 +1885,9 @@
 
 	ret = uart_remove_one_port(&atmel_uart, port);
 
+	if (gpio_is_valid(atmel_port->rs485_duplex_pin))
+		gpio_free(atmel_port->rs485_duplex_pin);
+
 	tasklet_kill(&atmel_port->tasklet);
 	kfree(atmel_port->rx_ring.buf);
 
